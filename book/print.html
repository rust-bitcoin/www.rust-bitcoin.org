<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Bitcoin Cookbook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="A cookbook for Rust Bitcoin development">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="tx.html"><strong aria-hidden="true">1.</strong> Constructing and Signing Transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tx_segwit-v0.html"><strong aria-hidden="true">1.1.</strong> SegWit V0</a></li><li class="chapter-item expanded "><a href="tx_taproot.html"><strong aria-hidden="true">1.2.</strong> Taproot</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Bitcoin Cookbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-bitcoin"><a class="header" href="#rust-bitcoin">Rust Bitcoin</a></h1>
<p><a href="https://creativecommons.org/publicdomain/zero/1.0/"><img src="https://img.shields.io/badge/License-CC0%201.0-lightgrey.svg" alt="CC0 1.0" /></a></p>
<p><a href="https://github.com/rust-bitcoin/rust-bitcoin"><code>rust-bitcoin</code></a> is a library for working with Bitcoin in Rust.
It contains Bitcoin network protocol and associated primitives.
You can find more by reading the <a href="https://docs.rs/bitcoin">documentation</a>.</p>
<p>To add <code>rust-bitcoin</code> to your project, run:</p>
<pre><code class="language-bash">cargo add bitcoin
</code></pre>
<p>Additionally, you can add flags to enable features.
Here's an example:</p>
<pre><code class="language-bash">cargo add bitcoin --features=rand-std
</code></pre>
<p>This cookbook provides straightforward examples that showcase effective approaches
for accomplishing typical Bitcoin-related programming tasks,
and utilizing the Rust ecosystem's crates.</p>
<p>The book covers various topics, including receiving data over P2P,
parsing blocks and transactions,
and constructing and signing transactions.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<p>This book contains:</p>
<ol>
<li><a href="tx.html">Constructing and Signing Transactions</a>
<ol>
<li><a href="tx_segwit-v0.html">SegWit V0</a></li>
<li><a href="tx_taproot.html">Taproot</a></li>
</ol>
</li>
</ol>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This website is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0 Universal (CC0 1.0) Public Domain Dedication</a>.</p>
<p><a href="https://creativecommons.org/publicdomain/zero/1.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/88x31.png" alt="CC BY-SA 4.0" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructing-and-signing-transactions"><a class="header" href="#constructing-and-signing-transactions">Constructing and Signing Transactions</a></h1>
<p>We provide the following examples:</p>
<ul>
<li><a href="tx_segwit-v0.html">Constructing and Signing Transactions - SegWit V0</a></li>
<li><a href="tx_taproot.html">Constructing and Signing Transactions - Taproot</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructing-and-signing-transactions---segwit-v0"><a class="header" href="#constructing-and-signing-transactions---segwit-v0">Constructing and Signing Transactions - SegWit V0</a></h1>
<p>In this section, we will construct a <a href="https://bitcoinops.org/en/topics/segregated-witness/">SegWit V0 transaction</a>.
This is the most common type of transaction on the Bitcoin network today<sup class="footnote-reference"><a href="#today">1</a></sup>.</p>
<p>This is the <code>cargo</code> commands that you need to run this example:</p>
<pre><code class="language-bash">cargo add bitcoin --features &quot;std, rand-std&quot;
</code></pre>
<p>First we'll need to import the following:</p>
<pre><code class="language-rust">use std::str::FromStr;

use bitcoin::hashes::Hash;
use bitcoin::locktime::absolute;
use bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing};
use bitcoin::sighash::{EcdsaSighashType, SighashCache};
use bitcoin::{
    Address, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, WPubkeyHash,
    Witness,
};</code></pre>
<p>Here is the logic behind these imports:</p>
<ul>
<li><code>std::str::FromStr</code> is used to parse strings into Bitcoin primitives</li>
<li><code>bitcoin::hashes::Hash</code> is used to hash data</li>
<li><code>bitcoin::locktime::absolute</code> is used to create a locktime</li>
<li><code>bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing}</code> is used to sign transactions</li>
<li><code>bitcoin::sighash::{EcdsaSighashType, SighashCache}</code> is used to create sighashes</li>
<li><code>bitcoin::{Address, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, WPubkeyHash, Witness}</code> is used to construct transactions</li>
</ul>
<p>Next, we define the following constants:</p>
<pre><code class="language-rust">const DUMMY_UTXO_AMOUNT: u64 = 20_000_000;
const SPEND_AMOUNT: u64 = 5_000_000;
const CHANGE_AMOUNT: u64 = 14_999_000; // 1000 sat fee.</code></pre>
<ul>
<li><code>DUMMY_UTXO_AMOUNT</code> is the amount of the dummy UTXO we will be spending</li>
<li><code>SPEND_AMOUNT</code> is the amount we will be spending from the dummy UTXO</li>
<li><code>CHANGE_AMOUNT</code><sup class="footnote-reference"><a href="#change">2</a></sup> is the amount we will be sending back to ourselves as change</li>
</ul>
<p>Before we can construct the transaction, we need to define some helper functions<sup class="footnote-reference"><a href="#expect">3</a></sup>:</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::secp256k1::{rand, Secp256k1, SecretKey, Signing};
</span><span class="boring">use bitcoin::WPubkeyHash;
</span>fn senders_keys&lt;C: Signing&gt;(secp: &amp;Secp256k1&lt;C&gt;) -&gt; (SecretKey, WPubkeyHash) {
    let sk = SecretKey::new(&amp;mut rand::thread_rng());
    let pk = bitcoin::PublicKey::new(sk.public_key(secp));
    let wpkh = pk.wpubkey_hash().expect(&quot;key is compressed&quot;);

    (sk, wpkh)
}</code></pre>
<p><code>senders_keys</code> generates a random private key and derives the corresponding public key hash.
This will be useful to mock a sender.
In a real application these would be actual secrets<sup class="footnote-reference"><a href="#secp">4</a></sup>.
We use the <code>SecretKey::new</code> method to generate a random private key <code>sk</code>.
We then use the <code>PublicKey::new</code> method to derive the corresponding public key <code>pk</code>.
Finally, we use the <code>PublicKey::wpubkey_hash</code> method to derive the corresponding public key hash <code>wpkh</code>.
Note that <code>senders_keys</code> is generic over the <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/trait.Signing.html"><code>Signing</code></a> trait.
This is used to indicate that is an instance of <code>Secp256k1</code> and can be used for signing.
We conclude returning the private key <code>sk</code> and the public key hash <code>wpkh</code> as a tuple.</p>
<pre><code class="language-rust"><span class="boring">use std::str::FromStr;
</span><span class="boring">use bitcoin::{Address, Network};
</span>fn receivers_address() -&gt; Address {
    Address::from_str(&quot;bc1q7cyrfmck2ffu2ud3rn5l5a8yv6f0chkp0zpemf&quot;)
        .expect(&quot;a valid address&quot;)
        .require_network(Network::Bitcoin)
        .expect(&quot;valid address for mainnet&quot;)
}</code></pre>
<p><code>receivers_address</code> generates a receiver address.
In a real application this would be the address of the receiver.
We use the method <code>Address::from_str</code> to parse the string <code>&quot;bc1q7cyrfmck2ffu2ud3rn5l5a8yv6f0chkp0zpemf&quot;</code> into an address.
Hence, it is necessary to import the <code>std::str::FromStr</code> trait.
Note that <code>bc1q7cyrfmck2ffu2ud3rn5l5a8yv6f0chkp0zpemf</code> is a <a href="https://bitcoinops.org/en/topics/bech32/">Bech32</a> address.
This is an arbitrary, however valid, Bitcoin mainnet address.
Hence we use the <code>require_network</code> method to ensure that the address is valid for mainnet.</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::{OutPoint, ScriptBuf, TxOut, Txid, WPubkeyHash};
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">const DUMMY_UTXO_AMOUNT: u64 = 20_000_000;
</span>fn dummy_unspent_transaction_output(wpkh: &amp;WPubkeyHash) -&gt; (OutPoint, TxOut) {
    let script_pubkey = ScriptBuf::new_v0_p2wpkh(wpkh);

    let out_point = OutPoint {
        txid: Txid::all_zeros(), // Obviously invalid.
        vout: 0,
    };

    let utxo = TxOut {
        value: DUMMY_UTXO_AMOUNT,
        script_pubkey,
    };

    (out_point, utxo)
}</code></pre>
<p><code>dummy_unspent_transaction_output</code> generates a dummy unspent transaction output (UTXO).
This is a SegWit V0 P2WPKH (<code>ScriptBuf::new_v0_p2wpkh</code>) UTXO with a dummy invalid transaction ID (<code>txid: Txid::all_zeros()</code>),
and a value of the <code>const DUMMY_UTXO_AMOUNT</code> that we defined earlier.
We are using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> struct to represent the transaction output.
Finally, we return the tuple <code>(out_point, utxo)</code>.</p>
<p>Now we are ready for our main function that will sign a transaction that spends a <code>p2wpkh</code> unspent output:</p>
<pre><code class="language-rust"><span class="boring">use std::str::FromStr;
</span><span class="boring">
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">use bitcoin::locktime::absolute;
</span><span class="boring">use bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing};
</span><span class="boring">use bitcoin::sighash::{EcdsaSighashType, SighashCache};
</span><span class="boring">use bitcoin::{
</span><span class="boring">    Address, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, WPubkeyHash,
</span><span class="boring">    Witness,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const DUMMY_UTXO_AMOUNT: u64 = 20_000_000;
</span><span class="boring">const SPEND_AMOUNT: u64 = 5_000_000;
</span><span class="boring">const CHANGE_AMOUNT: u64 = 14_999_000; // 1000 sat fee.
</span><span class="boring">
</span><span class="boring">fn senders_keys&lt;C: Signing&gt;(secp: &amp;Secp256k1&lt;C&gt;) -&gt; (SecretKey, WPubkeyHash) {
</span><span class="boring">    let sk = SecretKey::new(&amp;mut rand::thread_rng());
</span><span class="boring">    let pk = bitcoin::PublicKey::new(sk.public_key(secp));
</span><span class="boring">    let wpkh = pk.wpubkey_hash().expect(&quot;key is compressed&quot;);
</span><span class="boring">
</span><span class="boring">    (sk, wpkh)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn receivers_address() -&gt; Address {
</span><span class="boring">    Address::from_str(&quot;bc1q7cyrfmck2ffu2ud3rn5l5a8yv6f0chkp0zpemf&quot;)
</span><span class="boring">        .expect(&quot;a valid address&quot;)
</span><span class="boring">        .require_network(Network::Bitcoin)
</span><span class="boring">        .expect(&quot;valid address for mainnet&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn dummy_unspent_transaction_output(wpkh: &amp;WPubkeyHash) -&gt; (OutPoint, TxOut) {
</span><span class="boring">    let script_pubkey = ScriptBuf::new_v0_p2wpkh(wpkh);
</span><span class="boring">
</span><span class="boring">    let out_point = OutPoint {
</span><span class="boring">        txid: Txid::all_zeros(), // Obviously invalid.
</span><span class="boring">        vout: 0,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let utxo = TxOut {
</span><span class="boring">        value: DUMMY_UTXO_AMOUNT,
</span><span class="boring">        script_pubkey,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    (out_point, utxo)
</span><span class="boring">}
</span>
fn main() {
    let secp = Secp256k1::new();
    let (sk, wpkh) = senders_keys(&amp;secp);
    let address = receivers_address();
    let (dummy_out_point, dummy_utxo) = dummy_unspent_transaction_output(&amp;wpkh);

    // The script code required to spend a p2wpkh output.
    let script_code = dummy_utxo
        .script_pubkey
        .p2wpkh_script_code()
        .expect(&quot;valid script&quot;);

    // The input for the transaction we are constructing.
    let input = TxIn {
        previous_output: dummy_out_point,
        script_sig: ScriptBuf::new(),
        sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,
        witness: Witness::default(),
    };

    // The spend output is locked to a key controlled by the receiver.
    let spend = TxOut {
        value: SPEND_AMOUNT,
        script_pubkey: address.script_pubkey(),
    };

    // The change output is locked to a key controlled by us.
    let change = TxOut {
        value: CHANGE_AMOUNT,
        script_pubkey: ScriptBuf::new_v0_p2wpkh(&amp;wpkh),
    };

    // The transaction we want to sign and broadcast.
    let unsigned_tx = Transaction {
        version: 2,
        lock_time: absolute::LockTime::ZERO,
        input: vec![input],
        output: vec![spend, change],
    };

    // Sign the unsigned transaction.
    let mut sighash_cache = SighashCache::new(unsigned_tx);
    let sighash = sighash_cache
        .segwit_signature_hash(0, &amp;script_code, DUMMY_UTXO_AMOUNT, EcdsaSighashType::All)
        .expect(&quot;valid sighash&quot;);
    let msg = Message::from(sighash);
    let sig = secp.sign_ecdsa(&amp;msg, &amp;sk);

    // Convert into a transaction
    let mut tx = sighash_cache.into_transaction();

    // Update the witness stack
    let pk = sk.public_key(&amp;secp);
    let mut witness = &amp;mut tx.input[0].witness;
    witness.push_bitcoin_signature(
        &amp;sig.serialize_der(),
        EcdsaSighashType::All
    );
    witness.push(&amp;pk.serialize());

    // Print the transaction ready to broadcast
    println!(&quot;tx: {tx:?}&quot;);
}</code></pre>
<p>Let's go over the main function code block by block.</p>
<p><code>let secp = Secp256k1::new();</code> creates a new <code>Secp256k1</code> context with all capabilities.
Since we added the <code>rand-std</code> feature to our <code>Cargo.toml</code>,
we can use the <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Secp256k1.html#method.new"><code>SecretKey::new</code></a> method to generate a random private key <code>sk</code>.</p>
<p><code>let (sk, wpkh) = senders_keys(&amp;secp);</code> generates a random private key <code>sk</code> and derives the corresponding public key hash <code>wpkh</code>.
<code>let address = receivers_address();</code> generates a receiver's address <code>address</code>.
<code>let (dummy_out_point, dummy_utxo) = dummy_unspent_transaction_output(&amp;wpkh);</code> generates a dummy unspent transaction output <code>dummy_utxo</code> and its corresponding outpoint <code>dummy_out_point</code>.
All of these are helper functions that we defined earlier.</p>
<p><code>let script_code = dummy_utxo.script_pubkey.p2wpkh_script_code().expect(&quot;valid script&quot;);</code>
creates the script code required to spend a P2WPKH output.
Since <code>dummy_utxo</code> is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> type,
we can access the underlying public field <code>script_pubkey</code> which, in turn is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/script/struct.Script.html"><code>Script</code></a> type.
We then use the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.p2wpkh_script_code"><code>p2wpkh_script_code</code></a> method to generate the script code.</p>
<p>In <code>let input = TxIn {...}</code> we are instantiating the input for the transaction we are constructing
Inside the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.TxIn.html"><code>TxIn</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>previous_output</code> is the outpoint of the dummy UTXO we are spending; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> type.</li>
<li><code>script_sig</code> is the script code required to spend a P2WPKH output; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
It should be empty. That's why the <code>ScriptBuf::new()</code>.</li>
<li><code>sequence</code> is the sequence number; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.Sequence.html"><code>Sequence</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.Sequence.html#associatedconstant.ENABLE_RBF_NO_LOCKTIME"><code>ENABLE_RBF_NO_LOCKTIME</code></a> constant.</li>
<li><code>witness</code> is the witness stack; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/witness/struct.Witness.html"><code>Witness</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/witness/struct.Witness.html#impl-Default"><code>default</code></a> method to create an empty witness that will be filled in later after signing.
This is possible because <code>Witness</code> implements the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait.</li>
</ul>
<p>In <code>let spend = TxOut {...}</code> we are instantiating the spend output.
Inside the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>value</code> is the amount we are spending; it is a <a href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a> type.
We are using the <code>const SPEND_AMOUNT</code> that we defined earlier.</li>
<li><code>script_pubkey</code> is the script code required to spend a P2WPKH output; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/address/struct.Address.html#method.script_pubkey"><code>script_pubkey</code></a> method to generate the script pubkey from the receivers address.
This will lock the output to the receiver's address.</li>
</ul>
<p>In <code>let change = TxOut {...}</code> we are instantiating the change output.
It is very similar to the <code>spend</code> output, but we are now using the <code>const CHANGE_AMOUNT</code> that we defined earlier<sup class="footnote-reference"><a href="#spend">5</a></sup>.
This is done by setting the <code>script_pubkey</code> field to <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new_v0_p2wpkh"><code>ScriptBuf::new_v0_p2wpkh(&amp;wpkh)</code></a>,
which generates P2WPKH-type of script pubkey.</p>
<p>In <code>let unsigned_tx = Transaction {...}</code> we are instantiating the transaction we want to sign and broadcast using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.Transaction.html"><code>Transaction</code></a> struct.
We set the following fields:</p>
<ul>
<li><code>version</code> is the transaction version; it is a <a href="https://doc.rust-lang.org/std/primitive.u32.html"><code>i32</code></a> type.
We are using version <code>2</code> which means that <a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP68</a> applies.</li>
<li><code>lock_time</code> is the transaction lock time;
it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html"><code>LockTime</code></a> enum.
We are using the constant <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html#associatedconstant.ZERO"><code>ZERO</code></a>
This will make the transaction valid immediately.</li>
<li><code>input</code> is the input vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxIn&gt;</code></a> type.
We are using the <code>input</code> variable that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
<li><code>output</code> is the output vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxOut&gt;</code></a> type.
We are using the <code>spend</code> and <code>change</code> variables that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
</ul>
<p>In <code>let mut sighash_cache = SighashCache::new(unsigned_tx);</code> we are instantiating a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/struct.SighashCache.html"><code>SighashCache</code></a> struct.
This is a type that efficiently calculates <a href="https://developer.bitcoin.org/devguide/transactions.html?highlight=sighash_all#signature-hash-types">signature hash message</a> for legacy, segwit and taproot inputs.
We are using the <code>new</code> method to instantiate the struct with the <code>unsigned_tx</code> that we defined earlier.
<code>new</code> takes any <code>Borrow&lt;Transaction&gt;</code> as an argument.
<a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow&lt;T&gt;</code></a> is a trait that allows us to pass either a reference to a <code>T</code> or a <code>T</code> itself.
Hence, you can pass a <code>Transaction</code> or a <code>&amp;Transaction</code> to <code>new</code>.</p>
<p><code>sighash_cache</code> is instantiated as mutable because we require a mutable reference when creating the sighash to sign using <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/struct.SighashCache.html#method.segwit_signature_hash"><code>segwit_signature_hash</code></a>.
This computes the <a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP143</a> sighash for any flag type.
It takes the following arguments:</p>
<ul>
<li><code>input_index</code> is the index of the input we are signing; it is a <a href="https://doc.rust-lang.org/std/primitive.usize.html"><code>usize</code></a> type.
We are using <code>0</code> since we only have one input.</li>
<li><code>script_code</code> is the script code required to spend a P2WPKH output; it is a reference to <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/script/struct.Script.html"><code>Script</code></a> type.
We are using the <code>script_code</code> variable that we defined earlier.</li>
<li><code>value</code> is the amount of the UTXO we are spending; it is a <a href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a> type.
We are using the <code>const DUMMY_UTXO_AMOUNT</code> that we defined earlier.</li>
<li><code>sighash_type</code> is the type of sighash; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/enum.EcdsaSighashType.html"><code>EcdsaSighashType</code></a> enum.
We are using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/enum.EcdsaSighashType.html#variant.All"><code>All</code></a> variant,
which indicates that the sighash will include all the inputs and outputs.</li>
</ul>
<p>We create the message <code>msg</code> by converting the <code>sighash</code> to a <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Message.html"><code>Message</code></a> type.
This is the message that we will sign.
The <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Message.html#impl-From%3C%26%27_%20bitcoin%3A%3Ahashes%3A%3Asha256d%3A%3AHash%3E">Message::from</a> method takes anything that implements the promises to be a thirty two byte hash i.e., 32 bytes that came from a cryptographically secure hashing algorithm.</p>
<p>We compute the signature <code>sig</code> by using the <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Secp256k1.html#method.sign_ecdsa"><code>sign_ecdsa</code></a> method.
It takes a refence to a <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Message.html"><code>Message</code></a> and a reference to a <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.SecretKey.html"><code>SecretKey</code></a> as arguments,
and returns a <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/ecdsa/struct.Signature.html"><code>Signature</code></a> type.</p>
<p>In the next step, we update the witness stack for the input we just signed by first converting the <code>sighash_cache</code> into a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.Transaction.html"><code>Transaction</code></a>
by using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/struct.SighashCache.html#method.into_transaction"><code>into_transaction</code></a> method.
We access the witness field of the first input with <code>tx.input[0].witness</code>.
It is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/witness/struct.Witness.html"><code>Witness</code></a> type.
We use the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/witness/struct.Witness.html#method.push_bitcoin_signature"><code>push_bitcoin_signature</code></a> method.
It expects two arguments:</p>
<ol>
<li>A reference to a <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/ecdsa/serialized_signature/struct.SerializedSignature.html"><code>SerializedSignature</code></a> type.
This is accomplished by calling the <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/ecdsa/struct.Signature.html#method.serialize_der"><code>serialize_der</code></a> method on the <code>Signature</code> <code>sig</code>,
which returns a <code>SerializedSignature</code> type.</li>
<li>A <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/enum.EcdsaSighashType.html"><code>EcdsaSighashType</code></a> enum.
Again we are using the same <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/enum.EcdsaSighashType.html#variant.All"><code>All</code></a> variant that we used earlier.</li>
</ol>
<p>We repeat the same step as above, but now using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/witness/struct.Witness.html#method.push"><code>push</code></a> method
to push the serialized public key to the witness stack.
It expects a single argument of type <code>AsRef&lt;[u8]&gt;</code> which is a reference to a byte slice.</p>
<p>As the last step we print this to terminal using the <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a> macro.
This transaction is now ready to be broadcast to the Bitcoin network.</p>
<!-- markdown-link-check-disable -->
<div class="footnote-definition" id="today"><sup class="footnote-definition-label">1</sup>
<p>mid-2023.</p>
<!-- markdown-link-check-enable -->
</div>
<div class="footnote-definition" id="change"><sup class="footnote-definition-label">2</sup>
<p>Please note that the <code>CHANGE_AMOUNT</code> is not the same as the <code>DUMMY_UTXO_AMOUNT</code> minus the <code>SPEND_AMOUNT</code>.
This is due to the fact that we need to pay a fee for the transaction.</p>
</div>
<div class="footnote-definition" id="expect"><sup class="footnote-definition-label">3</sup>
<p>We will be unwraping any <a href="https://doc.rust-lang.org/std/option"><code>Option&lt;T&gt;</code></a>/<a href="https://doc.rust-lang.org/std/result"><code>Result&lt;T, E&gt;</code></a>
with the <code>expect</code> method.</p>
</div>
<div class="footnote-definition" id="secp"><sup class="footnote-definition-label">4</sup>
<p>Under the hood we are using the <a href="https://github.com/rust-bitcoin/rust-secp256k1/"><code>secp256k1</code></a> crate to generate the key pair.
<code>rust-secp256k1</code> is a wrapper around <a href="https://github.com/bitcoin-core/secp256k1">libsecp256k1</a>, a C
library implementing various cryptographic functions using the <a href="https://www.secg.org/">SECG</a> curve
<a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1</a>.</p>
</div>
<div class="footnote-definition" id="spend"><sup class="footnote-definition-label">5</sup>
<p>And also we are locking the output to an address that we control:
the <code>wpkh</code> public key hash that we generated earlier. </p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructing-and-signing-transactions---taproot"><a class="header" href="#constructing-and-signing-transactions---taproot">Constructing and Signing Transactions - Taproot</a></h1>
<p>In this section, we will construct a <a href="https://bitcoinops.org/en/topics/taproot/">Taproot transaction</a>.</p>
<p>This is the <code>cargo</code> commands that you need to run this example:</p>
<pre><code class="language-bash">cargo add bitcoin --features &quot;std, rand-std&quot;
</code></pre>
<p>First we'll need to import the following:</p>
<pre><code class="language-rust">use std::str::FromStr;

use bitcoin::hashes::Hash;
use bitcoin::key::{KeyPair, TapTweak, TweakedKeyPair, UntweakedPublicKey};
use bitcoin::locktime::absolute;
use bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing, Verification};
use bitcoin::sighash::{Prevouts, SighashCache, TapSighashType};
use bitcoin::{
    Address, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, Witness,
};</code></pre>
<p>Here is the logic behind these imports:</p>
<ul>
<li><code>std::str::FromStr</code> is used to parse strings into Bitcoin primitives</li>
<li><code>bitcoin::key</code> is used to tweak keys according to <a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP340</a></li>
<li><code>bitcoin::hashes::Hash</code> is used to hash data</li>
<li><code>bitcoin::locktime::absolute</code> is used to create a locktime</li>
<li><code>bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing, Verification}</code> is used to sign transactions</li>
<li><code>use bitcoin::sighash::{Prevouts, SighashCache, TapSighashType}</code> is used to create and tweak taproot sighashes</li>
<li><code>bitcoin::{Address, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, Witness}</code> is used to construct transactions</li>
</ul>
<p>Next, we define the following constants:</p>
<pre><code class="language-rust">const DUMMY_UTXO_AMOUNT: u64 = 20_000_000;
const SPEND_AMOUNT: u64 = 5_000_000;
const CHANGE_AMOUNT: u64 = 14_999_000; // 1000 sat fee.</code></pre>
<ul>
<li><code>DUMMY_UTXO_AMOUNT</code> is the amount of the dummy UTXO we will be spending</li>
<li><code>SPEND_AMOUNT</code> is the amount we will be spending from the dummy UTXO</li>
<li><code>CHANGE_AMOUNT</code><sup class="footnote-reference"><a href="#change">1</a></sup> is the amount we will be sending back to ourselves as change</li>
</ul>
<p>Before we can construct the transaction, we need to define some helper functions<sup class="footnote-reference"><a href="#expect">2</a></sup>:</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::secp256k1::{rand, Secp256k1, SecretKey, Signing};
</span><span class="boring">use bitcoin::key::KeyPair;
</span>fn senders_keys&lt;C: Signing&gt;(secp: &amp;Secp256k1&lt;C&gt;) -&gt; KeyPair {
    let sk = SecretKey::new(&amp;mut rand::thread_rng());
    KeyPair::from_secret_key(secp, &amp;sk)
}</code></pre>
<p><code>senders_keys</code> generates a random private key and derives the corresponding public key hash.
This will be useful to mock a sender.
In a real application these would be actual secrets<sup class="footnote-reference"><a href="#secp">3</a></sup>.
We use the <code>SecretKey::new</code> method to generate a random private key <code>sk</code>.
We then use the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/key/struct.KeyPair.html#method.from_secret_key"><code>KeyPair::from_secret_key</code></a> method to instatiate a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/key/struct.KeyPair.html"><code>KeyPair</code></a> type,
which is a data structure that holds a keypair consisting of a secret and a public key.
Note that <code>senders_keys</code> is generic over the <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/trait.Signing.html"><code>Signing</code></a> trait.
This is used to indicate that is an instance of <code>Secp256k1</code> and can be used for signing.</p>
<pre><code class="language-rust"><span class="boring">use std::str::FromStr;
</span><span class="boring">use bitcoin::{Address, Network};
</span>fn receivers_address() -&gt; Address {
    Address::from_str(&quot;bc1p0dq0tzg2r780hldthn5mrznmpxsxc0jux5f20fwj0z3wqxxk6fpqm7q0va&quot;)
        .expect(&quot;a valid address&quot;)
        .require_network(Network::Bitcoin)
        .expect(&quot;valid address for mainnet&quot;)
}</code></pre>
<p><code>receivers_address</code> generates a receiver address.
In a real application this would be the address of the receiver.
We use the method <code>Address::from_str</code> to parse the string <code>&quot;bc1p0dq0tzg2r780hldthn5mrznmpxsxc0jux5f20fwj0z3wqxxk6fpqm7q0va&quot;</code><sup class="footnote-reference"><a href="#arbitrary_address">4</a></sup> into an address.
Hence, it is necessary to import the <code>std::str::FromStr</code> trait.
Note that <code>bc1p0dq0tzg2r780hldthn5mrznmpxsxc0jux5f20fwj0z3wqxxk6fpqm7q0va</code> is a <a href="https://bitcoinops.org/en/topics/bech32/">Bech32</a> address.
This is an arbitrary, however valid, Bitcoin mainnet address.
Hence we use the <code>require_network</code> method to ensure that the address is valid for mainnet.</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::{OutPoint, ScriptBuf, TxOut, Txid};
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">use bitcoin::key::UntweakedPublicKey;
</span><span class="boring">use bitcoin::locktime::absolute;
</span><span class="boring">use bitcoin::secp256k1::{Secp256k1, Verification};
</span><span class="boring">const DUMMY_UTXO_AMOUNT: u64 = 20_000_000;
</span>fn dummy_unspent_transaction_output&lt;C: Verification&gt;(
   secp: &amp;Secp256k1&lt;C&gt;,
   internal_key: UntweakedPublicKey,
) -&gt; (OutPoint, TxOut) {
    let script_pubkey = ScriptBuf::new_v1_p2tr(secp, internal_key, None);

    let out_point = OutPoint {
        txid: Txid::all_zeros(), // Obviously invalid.
        vout: 0,
    };

    let utxo = TxOut {
        value: DUMMY_UTXO_AMOUNT,
        script_pubkey,
    };

    (out_point, utxo)
}</code></pre>
<p><code>dummy_unspent_transaction_output</code> generates a dummy unspent transaction output (UTXO).
This is a P2TR (<code>ScriptBuf::new_v1_p2tr</code>) UTXO.
It takes the following arguments:</p>
<ul>
<li><code>secp</code> is a reference to a <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Secp256k1.html"><code>Secp256k1</code></a> type.
This is used to verify the internal key.</li>
<li><code>internal_key</code> is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/key/type.UntweakedPublicKey.html"><code>UntweakedPublicKey</code></a> type.
This is the internal key that is used to generate the script pubkey.
It is untweaked, since we are not going to tweak the key.</li>
<li><code>merkle_root</code> is an optional <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/taproot/struct.TapNodeHash.html"><code>TapNodeHash</code></a> type.
This is the merkle root of the taproot tree.
Since we are not using a merkle tree, we are passing <code>None</code>.</li>
</ul>
<p><a href="https://docs.rs/bitcoin/0.30.0/bitcoin/key/trait.Verification.html"><code>Verification</code></a> is a trait that indicates that an instance of <code>Secp256k1</code> can be used for verification.
The UTXO has a dummy invalid transaction ID (<code>txid: Txid::all_zeros()</code>),
and a value of the <code>const DUMMY_UTXO_AMOUNT</code> that we defined earlier.
P2TR UTXOs could be tweaked (<a href="https://docs.rs/bitcoin/0.30.0/bitcoin/key/struct.TweakedPublicKey.html"><code>TweakedPublicKey</code></a>)
or untweaked (<a href="https://docs.rs/bitcoin/0.30.0/bitcoin/key/type.UntweakedPublicKey.html"><code>UntweakedPublicKey</code></a>).
We are using the latter, since we are not going to tweak the key.
We are using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> struct to represent the transaction output.
Finally, we return the tuple <code>(out_point, utxo)</code>.</p>
<p>Now we are ready for our main function that will sign a transaction that spends a <code>p2wpkh</code> unspent output:</p>
<pre><code class="language-rust"><span class="boring">use std::str::FromStr;
</span><span class="boring">
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">use bitcoin::key::{KeyPair, TapTweak, TweakedKeyPair, UntweakedPublicKey};
</span><span class="boring">use bitcoin::locktime::absolute;
</span><span class="boring">use bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing, Verification};
</span><span class="boring">use bitcoin::sighash::{Prevouts, SighashCache, TapSighashType};
</span><span class="boring">use bitcoin::{
</span><span class="boring">    Address, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, Witness,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const DUMMY_UTXO_AMOUNT: u64 = 20_000_000;
</span><span class="boring">const SPEND_AMOUNT: u64 = 5_000_000;
</span><span class="boring">const CHANGE_AMOUNT: u64 = 14_999_000; // 1000 sat fee.
</span><span class="boring">
</span><span class="boring">fn senders_keys&lt;C: Signing&gt;(secp: &amp;Secp256k1&lt;C&gt;) -&gt; KeyPair {
</span><span class="boring">    let sk = SecretKey::new(&amp;mut rand::thread_rng());
</span><span class="boring">    KeyPair::from_secret_key(secp, &amp;sk)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn receivers_address() -&gt; Address {
</span><span class="boring">    Address::from_str(&quot;bc1p0dq0tzg2r780hldthn5mrznmpxsxc0jux5f20fwj0z3wqxxk6fpqm7q0va&quot;)
</span><span class="boring">        .expect(&quot;a valid address&quot;)
</span><span class="boring">        .require_network(Network::Bitcoin)
</span><span class="boring">        .expect(&quot;valid address for mainnet&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn dummy_unspent_transaction_output&lt;C: Verification&gt;(
</span><span class="boring">   secp: &amp;Secp256k1&lt;C&gt;,
</span><span class="boring">   internal_key: UntweakedPublicKey,
</span><span class="boring">) -&gt; (OutPoint, TxOut) {
</span><span class="boring">    let script_pubkey = ScriptBuf::new_v1_p2tr(secp, internal_key, None);
</span><span class="boring">
</span><span class="boring">    let out_point = OutPoint {
</span><span class="boring">        txid: Txid::all_zeros(), // Obviously invalid.
</span><span class="boring">        vout: 0,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let utxo = TxOut {
</span><span class="boring">        value: DUMMY_UTXO_AMOUNT,
</span><span class="boring">        script_pubkey,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    (out_point, utxo)
</span><span class="boring">}
</span>
fn main() {
    let secp = Secp256k1::new();
    let keypair = senders_keys(&amp;secp);
    let (internal_key, _parity) = keypair.x_only_public_key();
    let address = receivers_address();
    let (dummy_out_point, dummy_utxo) = dummy_unspent_transaction_output(&amp;secp, internal_key);

    // The input for the transaction we are constructing.
    let input = TxIn {
        previous_output: dummy_out_point,
        script_sig: ScriptBuf::new(),
        sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,
        witness: Witness::default(),
    };

    // The spend output is locked to a key controlled by the receiver.
    let spend = TxOut {
        value: SPEND_AMOUNT,
        script_pubkey: address.script_pubkey(),
    };

    // The change output is locked to a key controlled by us.
    let change = TxOut {
        value: CHANGE_AMOUNT,
       script_pubkey: ScriptBuf::new_v1_p2tr(&amp;secp, internal_key, None),
    };

    // The transaction we want to sign and broadcast.
    let unsigned_tx = Transaction {
        version: 2,
        lock_time: absolute::LockTime::ZERO,
        input: vec![input],
        output: vec![spend, change],
    };

    // Create the prevouts
    let prevouts = vec![dummy_utxo];
    let prevouts = Prevouts::All(&amp;prevouts);

    // Sign the unsigned transaction.
    let mut sighash_cache = SighashCache::new(unsigned_tx);
    let sighash = sighash_cache
        .taproot_signature_hash(0, &amp;prevouts, None, None, TapSighashType::Default)
        .expect(&quot;valid sighash&quot;);
    let tweaked: TweakedKeyPair = keypair.tap_tweak(&amp;secp, None);
    let msg = Message::from(sighash);
    let sig = secp.sign_schnorr(&amp;msg, &amp;tweaked.to_inner());

    // Convert into a transaction
    let mut tx = sighash_cache.into_transaction();

    // Update the witness stack
    let mut witness = &amp;mut tx.input[0].witness;
    witness.push(sig.as_ref());

    // Print the transaction ready to broadcast
    println!(&quot;tx: {tx:?}&quot;);
}</code></pre>
<p>Let's go over the main function code block by block.</p>
<p><code>let secp = Secp256k1::new();</code> creates a new <code>Secp256k1</code> context with all capabilities.
Since we added the <code>rand-std</code> feature to our <code>Cargo.toml</code>,
we can use the <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Secp256k1.html#method.new"><code>SecretKey::new</code></a> method to generate a random private key <code>sk</code>.</p>
<p><code>let keypair = senders_keys(&amp;secp);</code> generates a keypair that we control,
and <code>let (internal_key, _parity) = keypair.x_only_public_key();</code> generates a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/key/struct.XOnlyPublicKey.html"><code>XOnlyPublicKey</code></a> that represent an X-only public key, used for verification of Schnorr signatures according to <a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP340</a>.
We won't be using second element from the returned tuple, the parity, so we are ignoring it by using the <code>_</code> underscore.
<code>let address = receivers_address();</code> generates a receiver's address <code>address</code>.
<code>let (dummy_out_point, dummy_utxo) = dummy_unspent_transaction_output(&amp;wpkh);</code> generates a dummy unspent transaction output <code>dummy_utxo</code> and its corresponding outpoint <code>dummy_out_point</code>.
All of these are helper functions that we defined earlier.</p>
<p>In <code>let input = TxIn {...}</code> we are instantiating the input for the transaction we are constructing
Inside the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.TxIn.html"><code>TxIn</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>previous_output</code> is the outpoint of the dummy UTXO we are spending; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> type.</li>
<li><code>script_sig</code> is the script code required to spend an output; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
We are instantiating a new empty script with <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new"><code>ScriptBuf::new()</code></a>.</li>
<li><code>sequence</code> is the sequence number; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.Sequence.html"><code>Sequence</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.Sequence.html#associatedconstant.ENABLE_RBF_NO_LOCKTIME"><code>ENABLE_RBF_NO_LOCKTIME</code></a> constant.</li>
<li><code>witness</code> is the witness stack; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/witness/struct.Witness.html"><code>Witness</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/witness/struct.Witness.html#impl-Default"><code>default</code></a> method to create an empty witness that will be filled in later after signing.
This is possible because <code>Witness</code> implements the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait.</li>
</ul>
<p>In <code>let spend = TxOut {...}</code> we are instantiating the spend output.
Inside the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>value</code> is the amount we are spending; it is a <a href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a> type.
We are using the <code>const SPEND_AMOUNT</code> that we defined earlier.</li>
<li><code>script_pubkey</code> is the script code required to spend a P2TR output; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/address/struct.Address.html#method.script_pubkey"><code>script_pubkey</code></a> method to generate the script pubkey from the receivers address.
This will lock the output to the receiver's address.</li>
</ul>
<p>In <code>let change = TxOut {...}</code> we are instantiating the change output.
It is very similar to the <code>spend</code> output, but we are now using the <code>const CHANGE_AMOUNT</code> that we defined earlier<sup class="footnote-reference"><a href="#spend">5</a></sup>.
This is done by setting the <code>script_pubkey</code> field to <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new_v1_p2tr"><code>ScriptBuf::new_v1_p2tr(...)</code></a>,
which generates P2TR-type of script pubkey.</p>
<p>In <code>let unsigned_tx = Transaction {...}</code> we are instantiating the transaction we want to sign and broadcast using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.Transaction.html"><code>Transaction</code></a> struct.
We set the following fields:</p>
<ul>
<li><code>version</code> is the transaction version; it is a <a href="https://doc.rust-lang.org/std/primitive.u32.html"><code>i32</code></a> type.
We are using version <code>2</code> which means that <a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP68</a> applies.</li>
<li><code>lock_time</code> is the transaction lock time;
it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html"><code>LockTime</code></a> enum.
We are using the constant <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html#associatedconstant.ZERO"><code>ZERO</code></a>
This will make the transaction valid immediately.</li>
<li><code>input</code> is the input vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxIn&gt;</code></a> type.
We are using the <code>input</code> variable that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
<li><code>output</code> is the output vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxOut&gt;</code></a> type.
We are using the <code>spend</code> and <code>change</code> variables that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
</ul>
<p>We need to reference the outputs of previous transactions in our transaction.
We accomplish this with the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/enum.Prevouts.html"><code>Prevouts</code></a> enum.
In <code>let prevouts = vec![dummy_utxo];</code>,
we create a vector of <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> types that we want to reference.
In our case, we only have one output, the <code>dummy_utxo</code> that we defined earlier.
With <code>let prevouts = Prevouts::All(&amp;prevouts);</code> we create a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/enum.Prevouts.html#variant.All"><code>Prevouts::All</code></a> variant that takes a reference to a vector of <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> types.</p>
<p>In <code>let mut sighash_cache = SighashCache::new(unsigned_tx);</code> we are instantiating a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/struct.SighashCache.html"><code>SighashCache</code></a> struct.
This is a type that efficiently calculates <a href="https://developer.bitcoin.org/devguide/transactions.html?highlight=sighash_all#signature-hash-types">signature hash message</a> for legacy, segwit and taproot inputs.
We are using the <code>new</code> method to instantiate the struct with the <code>unsigned_tx</code> that we defined earlier.
<code>new</code> takes any <code>Borrow&lt;Transaction&gt;</code> as an argument.
<a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow&lt;T&gt;</code></a> is a trait that allows us to pass either a reference to a <code>T</code> or a <code>T</code> itself.
Hence, you can pass a <code>Transaction</code> or a <code>&amp;Transaction</code> to <code>new</code>.</p>
<p><code>sighash_cache</code> is instantiated as mutable because we require a mutable reference when creating the sighash to sign using <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/struct.SighashCache.html#method.taproot_signature_hash"><code>taproot_signature_hash</code></a> to it.
This computes the <a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP341</a> sighash for any flag type.
It takes the following arguments:</p>
<ul>
<li><code>input_index</code> is the index of the input we are signing; it is a <a href="https://doc.rust-lang.org/std/primitive.usize.html"><code>usize</code></a> type.
We are using <code>0</code> since we only have one input.</li>
<li><code>&amp;prevouts</code> is a refence to the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/enum.Prevouts.html"><code>Prevouts</code></a> enum that we defined earlier.
This is used to reference the outputs of previous transactions and also used to calculate our transaction value.</li>
<li><code>annex</code> is an optional argument that is used to pass the annex data.
We are not using it, so we are passing <code>None</code>.</li>
<li><code>leaf_hash_code_separator</code> is an optional argument that is used to pass the leaf hash code separator.
We are not using it, so we are passing <code>None</code>.</li>
<li><code>sighash_type</code> is the type of sighash; it is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/enum.TapSighashType.html"><code>TapSighashType</code></a> enum.
We are using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/enum.TapSighashType.html#variant.All"><code>All</code></a> variant,
which indicates that the sighash will include all the inputs and outputs.</li>
</ul>
<p>Taproot signatures are generated by tweaking the private (and public) key(s).
<code>let tweaked: TweakedKeyPair = keypair.tap_tweak(&amp;secp, None);</code> accomplishes this.</p>
<p>We create the message <code>msg</code> by converting the <code>sighash</code> to a <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Message.html"><code>Message</code></a> type.
This is a the message that we will sign.
The <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Message.html#impl-From%3C%26%27_%20bitcoin%3A%3Ahashes%3A%3Asha256d%3A%3AHash%3E">Message::from</a> method takes anything that implements the promises to be a thirty two byte hash i.e., 32 bytes that came from a cryptographically secure hashing algorithm.</p>
<p>We compute the signature <code>sig</code> by using the <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Secp256k1.html#method.sign_schnorr"><code>sign_schnorr</code></a> method.
It takes a refence to a <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.Message.html"><code>Message</code></a> and a reference to a <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/struct.KeyPair.html"><code>KeyPair</code></a> as arguments,
and returns a <a href="https://docs.rs/secp256k1/0.27.0/secp256k1/ecdsa/struct.Signature.html"><code>Signature</code></a> type.</p>
<p>In the next step, we update the witness stack for the input we just signed by first converting the <code>sighash_cache</code> into a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/transaction/struct.Transaction.html"><code>Transaction</code></a>
by using the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/sighash/struct.SighashCache.html#method.into_transaction"><code>into_transaction</code></a> method.
We access the witness field of the first input with <code>tx.input[0].witness</code>.
It is a <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/witness/struct.Witness.html"><code>Witness</code></a> type.
We use the <a href="https://docs.rs/bitcoin/0.30.0/bitcoin/blockdata/witness/struct.Witness.html#method.push"><code>push</code></a> method
to push the serialized public and private Taproot keys.
It expects a single argument of type <code>AsRef&lt;[u8]&gt;</code> which is a reference to a byte slice.
We are using the <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>as_ref</code></a> method to convert the signature <code>sig</code> to a byte slice.</p>
<p>As the last step we print this to terminal using the <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a> macro.
This transaction is now ready to be broadcast to the Bitcoin network.</p>
<div class="footnote-definition" id="change"><sup class="footnote-definition-label">1</sup>
<p>Please note that the <code>CHANGE_AMOUNT</code> is not the same as the <code>DUMMY_UTXO_AMOUNT</code> minus the <code>SPEND_AMOUNT</code>.
This is due to the fact that we need to pay a fee for the transaction.</p>
</div>
<div class="footnote-definition" id="expect"><sup class="footnote-definition-label">2</sup>
<p>We will be unwraping any <a href="https://doc.rust-lang.org/std/option"><code>Option&lt;T&gt;</code></a>/<a href="https://doc.rust-lang.org/std/result"><code>Result&lt;T, E&gt;</code></a>
with the <code>expect</code> method.</p>
</div>
<div class="footnote-definition" id="secp"><sup class="footnote-definition-label">3</sup>
<p>Under the hood we are using the <a href="https://github.com/rust-bitcoin/rust-secp256k1/"><code>secp256k1</code></a> crate to generate the key pair.
<code>rust-secp256k1</code> is a wrapper around <a href="https://github.com/bitcoin-core/secp256k1">libsecp256k1</a>, a C
library implementing various cryptographic functions using the <a href="https://www.secg.org/">SECG</a> curve
<a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1</a>.</p>
</div>
<div class="footnote-definition" id="arbitrary_address"><sup class="footnote-definition-label">4</sup>
<p>this is an arbitrary mainnet address from block 805222.</p>
</div>
<div class="footnote-definition" id="spend"><sup class="footnote-definition-label">5</sup>
<p>And also we are locking the output to an address that we control:
the <code>internal_key</code> public key hash that we generated earlier.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
